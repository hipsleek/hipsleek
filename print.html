<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The HIP/SLEEK system</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The HIP/SLEEK system</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>HIP/SLEEK is an automated program verification framework based on separation logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-hip-and-sleek"><a class="header" href="#building-hip-and-sleek">Building HIP and SLEEK</a></h2>
<p>You will need opam and a recent OCaml compiler (tested on 4.14.1).</p>
<pre><code class="language-sh">opam install . --deps-only
dune build @hipsleek

# To use ocamldebug
rake debug:hip debug:sleek
</code></pre>
<p>Try verifying some small programs.
You will need Z3 (from opam, pip, or a system package manager) and Omega (<a href="install.html#omega">below</a>) on the PATH.</p>
<pre><code class="language-sh">dune exec ./hip.exe dune-tests/hip/ll.t/ll.ss
dune exec ./sleek.exe dune-tests/sleek/sleek2.t/sleek2.ss
</code></pre>
<h2 id="installing-sleek-as-a-library"><a class="header" href="#installing-sleek-as-a-library">Installing SLEEK as a library</a></h2>
<pre><code class="language-sh">opam install .
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<pre><code class="language-sh">dune test
</code></pre>
<h2 id="installing-external-provers"><a class="header" href="#installing-external-provers">Installing external provers</a></h2>
<p>Other external provers HIP/SLEEK uses can be built from source.
They will be installed in their respective directories and should be made available on the PATH.</p>
<p>Here is an example .envrc file which makes all the provers available, after following the steps below to build each one:</p>
<pre><code class="language-envrc">eval "$(opam env --switch=4.14.1 --set-switch)"
PATH_add omega_modified/omega_calc/obj
PATH_add mona-1.4/bin
PATH_add fixcalc_src
</code></pre>
<h3 id="omega"><a class="header" href="#omega">Omega</a></h3>
<pre><code class="language-sh">(cd omega_modified; make oc)
</code></pre>
<h3 id="mona"><a class="header" href="#mona">Mona</a></h3>
<pre><code class="language-sh">tar -xvf mona-1.4-modif.tar.gz
cd mona-1.4
./configure --prefix=$(pwd)
make install
cp mona_predicates.mona ..
cd -
</code></pre>
<p>Try some tests:</p>
<pre><code class="language-sh">./hip -tp mona dune-tests/hip/ll.t/ll.ss
./sleek -tp mona dune-tests/sleek/sleek2.t/sleek2.ss
</code></pre>
<h3 id="fixcalc"><a class="header" href="#fixcalc">Fixcalc</a></h3>
<p>You will need GHC 9.4.8.</p>
<pre><code class="language-sh">cabal install --lib regex-compat old-time
cabal install happy
</code></pre>
<p>Build <a href="install.html#omega">Omega</a> first. Then, in the hipsleek project directory,</p>
<pre><code class="language-sh">git clone https://github.com/hipsleek/omega_stub.git
(cd omega_stub; make)

git clone https://github.com/hipsleek/fixcalc.git fixcalc_src
(cd fixcalc_src; make fixcalc)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Some user-facing aspects of the system are described in the following papers.</p>
<ul>
<li>Automated Verification of Shape, Size and Bag Properties via User-Defined Predicates in Separation Logic (SCP 2012)</li>
<li>Structured Specifications for Better Verification of Heap-Manipulating Programs (FM 2011)</li>
<li>Immutable specifications for more concise and precise verification (OOPSLA 2011)</li>
<li>Translation and optimization for a core calculus with exceptions (PEPM 2009)</li>
<li>Enhancing Program Verification with Lemmas (CAV 2008)</li>
<li>Enhancing modular OO verification with separation logic (POPL 2008)</li>
<li>Multiple Pre/Post Specifications for Heap-Manipulating Methods. HASE 2007</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-language"><a class="header" href="#core-language">Core Language</a></h2>
<p>The following is an incomplete grammar of the core language.</p>
<pre><code>Spec_var ::= string ;

Ident ::= string ;

Type ::= string ;

Ghost ::= | "assert" Formula ; assertion
          | "dprint" ; print current state (?)
          | "unfold" Spec_var ; unfold specification variables

Ident_tuple ::= "()" | "(" Ident ("," Ident)* ")"

Expr ::= | integer ; integer constant
         | float ; float constant
         | "true" | "false" ; boolean constant
         | "if" Ident "[" Expr "]" "else" "[" Expr "]" ; conditional
         | "bind" Ident "to" Ident_tuple "in" Expr ; bind
         | Ident Ident_tuple ; function application
         | Ident "=" Expr ; assignment
         | Expr ";" Expr ; sequence
         | Ghost ; ghost expressions
         | "{" Expr "}" ; block
         | Type " " Ident ; variable declaration
         | "(" Type ")" Expr ; type casting (?)
         | "debug on" | "debug off" ; turning on or off devel debug
         | "while" (" Ident ")" Expr ; loop
         | "try" Expr "catch" "(" Type " " Ident ")" Expr ; try-catch
</code></pre>
<p>(Note that for <code>bind</code>, the number of bound variables must be equal to the number of
fields in the data declaration.)</p>
<h2 id="some-important-files"><a class="header" href="#some-important-files">Some important files</a></h2>
<ul>
<li><code>solver.ml</code></li>
<li><code>typechecker.ml</code></li>
<li><code>astsimp.ml</code></li>
</ul>
<h2 id="general-flow"><a class="header" href="#general-flow">General Flow</a></h2>
<p>Input file -- Parse --&gt; Input Ast (Iast) -- Normalization --&gt; Iast
-- Translation --&gt; Core Ast (Cast) -- Forward verification --&gt; Cast
-- Entailment checking --&gt; Done.</p>
<h3 id="normalization"><a class="header" href="#normalization">Normalization</a></h3>
<p>Relevant files : <code>astsimp.ml</code><br />
Relevant functions : <code>case_normalize_program</code>, <code>case_normalize_proc</code>,
<code>case_normalize_struc_formula</code></p>
<p>The following is a non-exhaustive list of normalization performed:</p>
<ul>
<li>While loops.</li>
</ul>
<pre><code>while Cond { Body }
-&gt;
let v_bool = Cond in
while v_bool { Body }
</code></pre>
<ul>
<li>Function application.</li>
</ul>
<pre><code>function_ident(expresssion_1,...,expression_n)
-&gt;
let v1 = expression_1 in
...
let vn = expression_n in
function_ident(v1,...,vn)
</code></pre>
<p>(Note the left to right evaluation of arguments)</p>
<h3 id="translation"><a class="header" href="#translation">Translation</a></h3>
<p>Relevant files : <code>astsimp.ml</code><br />
Relevant functions : <code>trans_prog</code>, <code>trans_proc</code>, <code>trans_views</code>, <code>trans_axiom</code>,
<code>trans_I2C_struc_formula</code>, <code>trans_exp</code></p>
<p>To have simpler rules for forward verification, HIPSLEEK first performs some
transformation on the Iast before translating it to Cast which is a simplified version
of Iast.</p>
<p>The following is a non-exhaustive list of transformation performed:</p>
<ul>
<li>Transform while statements to tail recursive top level functions.</li>
</ul>
<pre><code>while Cond { Body }
-&gt;
while_rec = if Cond [ Body; while_rec ]
            else []
</code></pre>
<p>(Note that <code>while_rec</code> is the new tail recursive function introduced during
transformation.)</p>
<ul>
<li>Transform break/continue to try-catch block.</li>
</ul>
<pre><code>while Cond {... break; ...}
-&gt;
while_rec =
try ( if Cond [ try { ... throw brk_default ... }
                catch (cnt_default) { };
                while_rec ]
     else [] )
catch (brk_default) { }
</code></pre>
<pre><code>while Cond {... continue; ...}
-&gt;
while_rec =
try ( if Cond [ try { ... throw cnt_default ... }
                catch (cnt_default) { };
                while_rec ]
     else [] )
catch (brk_default) { }
</code></pre>
<ul>
<li>Transform field accesses to bind.</li>
</ul>
<pre><code>x.f_i
-&gt;
bind x to (v_1,...,v_i,...,v_n) in v_i
</code></pre>
<pre><code>x.f_i = v
-&gt;
bind x to (v_1,...,v_i,...,v_n) in v_i = v
</code></pre>
<ul>
<li>Transform primitive operations to function calls.</li>
</ul>
<pre><code>x + y
-&gt;
add___$int~int(x, y)
</code></pre>
<p>(Note that these primitive functions are defined in <code>prelude.ss</code>.)</p>
<p>These transformations are done in <code>trans_exp</code> before translating to Cast.</p>
<h3 id="forward-verification"><a class="header" href="#forward-verification">Forward verification</a></h3>
<p>Relevant files : <code>typechecker.ml</code><br />
Relevant functions : <code>check_proc</code>, <code>check_specs_infer</code>, <code>check_exp</code></p>
<p><code>check_proc</code> is applied to every procedure/function in the program to be verified.</p>
<p><code>check_exp</code> essentially implements the forward verification rules. It will initialize
a proof state (<code>Cformula.list_failesc_context</code>) that contains the pre condition of
the function and walk through the body of the function.
While walking through the body of the function, it will update the proof state
according to the forward verification rules and the kind of expression in the body.</p>
<p>If there is a function call within the body of the function, <code>check_exp</code> will check
whether the proof state at the call site entails the pre condition of the
function being called. If it does, then the proof state after the call will be the
composition of the residue from the entailment checking and the post condition of the
function being called.</p>
<h3 id="entailment-checking"><a class="header" href="#entailment-checking">Entailment checking</a></h3>
<p>Relevant files : <code>typechecker.ml</code>, <code>solver.ml</code><br />
Relevant functions : <code>check_proc</code>, <code>check_specs_infer</code>, <code>check_post</code>,
<code>heap_entail_struc_list_partial_context_init</code></p>
<p>After <code>check_exp</code> returns the final proof state after walking through the entire body
of the function, <code>check_post</code> will be called with the final proof state.
It will then call <code>heap_entail_struc_list_partial_context_init</code> which will check whether
the final proof state entails the post condition of the function. It it does, then the
verification of the function succeeds. Otherwise, verification of the function fails.</p>
<h3 id="pure-logic-verification-conditions"><a class="header" href="#pure-logic-verification-conditions">Pure logic verification conditions</a></h3>
<p>Relevant files : <code>smtsolver.ml</code>, <code>z3.ml</code></p>
<p>Currently, by default, the prover discharges pure logic conditions to Z3 via invoking
the instance present on the <code>PATH</code>. Each formula is translated into an equivalent
statement in SMTLIB format, and the entailment (along with all custom relations,
axioms, etc.) is verified via Z3. Each possible return value (<code>sat</code>, <code>unsat</code>, <code>unknown</code>)
is then converted into either a proof success, or indicator of a may-failure or
must-failure (indicating an unknown result, or a known invalid entailment, respectively.)</p>
<p>For some pure values, some type information is necessary to properly generate
monomorphic SMT statements. Although type checking is done earlier in the process, (in
<code>typeinfer.ml</code> during the Iast-to-Cast lowering, and the aforementioned <code>typechecker.ml</code>),
the AST itself only contains partial type information (e.g. in spec var annotations.)
<code>cpure_ast_typeinfer.ml</code> attempts to extend these annotations to something more fully usable
by the SMT generator.</p>
<h1 id="api-docs"><a class="header" href="#api-docs">API docs</a></h1>
<hr />
<h2 id="limitations-of-api-possible-improvements"><a class="header" href="#limitations-of-api-possible-improvements">Limitations of API/ Possible improvements</a></h2>
<ul>
<li>Ghost statements (e.g. <code>assert</code>)</li>
<li>OOP</li>
<li>Termination checking</li>
<li>Better handling of failed proving than just throwing an exception</li>
</ul>
<h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<hr />
<p><strong>Q: What is a view?</strong></p>
<p><strong>A:</strong> Views are predicates.</p>
<p><strong>Q: What is Iast.proc_decl.proc_ho_arg?</strong></p>
<p><strong>A:</strong> Higher order arguments. They are currently not supported in the api.
Check out <code>rho/web/cdl-ex3-fm.ss</code> for example of these higher order arguments.
They are variables prefixed with <code>%</code> symbol. (e.g. <code>%P</code>).</p>
<p><strong>Q: What is the difference between dynamic and static specs?</strong></p>
<p><strong>A:</strong> Dynamic specs are used for OOP where dynamic binding is used to resolve method
calls at runtime and therefore function specs. Static specs should be used most of the
time.</p>
<p>**Q: What are instance call (Cast.ICall) and static calls (Cast.SCall)?</p>
<p><strong>A:</strong> Instance calls are used for method calls in OOP and static calls are used for
both static method calls in OOP and regular function calls.</p>
<p><strong>Q: What is para continuation analysis?</strong></p>
<p><strong>A:</strong> Continuation analysis for views. To find out the continuation parameters
for each view in the program and insert them into the <code>Cast.view_cont_vars</code> field
of <code>Cast.view_decl</code>.
Examples for views with continuation parameters are <code>WFSegN</code> and <code>WFSeg</code> in
<code>prelude.ss</code>.</p>
<p><strong>Q: What does Astsimp.compute_view_x_formula do?</strong></p>
<p><strong>A:</strong> Uses Xpure approximation on predicate to compute predicate invariant.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
