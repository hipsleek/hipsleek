data node {
  int val;
  node next;
}.

// (1) residue must not contain v
infer [] y::node<_,_>@w |- (exists v: y::node<a,b>@v).
print residue.

// (2) explicit (residue to have w<:v)
infer [] y::node<_,_>@w |- [v] y::node<a,b>@v.
print residue.

// (3) implicit (see residue to have w=v)
infer [] y::node<_,_>@w |- y::node<a,b>@v.
print residue.

// (4)
infer [] @L<:v & v<:@M |- false.

// (5)
infer [] @L<:v |- v=@L.

// (6)
infer [] v<:@M |- v=@M.

// (7)
infer [] true |- @M<:@I & @I<:@L.

// (8) fail
infer [] true |- @I<:@M.

// (9) fail
infer [] true |- @L<:@I.

// (10) valid
infer [] y::node<_,_>@M |- y::node<a,b>@v & v<:@M.

// (11)
infer [] y::node<_,_>@v & v<:@M |- y::node<a,b>@M.

// (12)
infer [] y::node<_,_>@L |- y::node<a,b>@v & v<:@L.

// (13)
infer [] y::node<_,_>@v & v<:@L |- y::node<a,b>@L.

// (14) valid
infer [] y::node<_,_>@I |- y::node<a,b>@v & v<:@I.

// (15)
infer [] y::node<_,_>@v & v<:@I |- y::node<a,b>@I.

// (16)
infer [] y::node<_,_>@v |- y::node<a,b>@L.

// (17) fail
infer [] y::node<_,_>@v |- y::node<a,b>@I.

// (18)
infer [] @L<:v & v<:@M |- false.

// (19) fail
infer [] y::node<_,_>@L |- [v] y::node<a,b>@v & v<:@M.

// (20)
infer [] y::node<_,_>@w |- y::node<a,b>@w .

// (21) fail
infer [] y::node<_,_>@w & w<:@I |- y::node<a,b>@M .

// (22) fail
infer [] y::node<_,_>@w & w<:@L |- y::node<a,b>@I .

// (23) 
infer [] y::node<_,_>@w & w<:@M |- y::node<a,b>@I .

// (24) 
infer [] y::node<_,_>@w & w<:@M |- y::node<a,b>@L .

// (25) 
infer [] y::node<_,_>@w & w<:@I |- y::node<a,b>@L .

//infer [y] true |- y::node<a,b>@v & v<:L.
//infer [y,w] y::node<_,_>@w |- y::node<a,b>@v & v<:L.
//print residue.
