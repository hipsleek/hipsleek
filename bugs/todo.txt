# test3.slk # DONE 

Inference has three basic problems in above file/

//(4).
infer[n] x::ll<n> |- x::node<_,null>.
print residue.
/*
This is WRONG! Previously, we got n=1 as inferred constraint.

Entail (4) : Fail.
*/

//(10).
infer[Q] x::node<_,y> * y::ll<n2> & 
Q(n1-1, n2, n3) & n1>0 |- x::ll<n3> & Q(n1,n2,n3).
print residue.
/*
The RELASS are wrong here. n3=n2+1 should have been instantiated
and n3=1 occurs when n2=0 presumably.

 <1>emp&Q(-1+n1,n2,n3) & 0<n1 & Anon_183=Anon_21 & r_184=y & n3=n2+1 & n3=1&{FLOW,(19,20)=__norm}[]
 inferred rel: [RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=n2+1; 
                RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=1; 
                RELDEFN Q: ( 1<=n1 & 0<=n2 & Q(-1+n1,n2,n3)) -->  Q(n1,n2,n3)]
*/



#



added memo_Pure re-patch;
      should do it more selectively

has assert been specialised?
  --> specialised on the fly

qsort
=====
 q is existential.. 
 prune baga conditions: (self,q)-163,(self)-162
 

use propagation and simplication for pruning conditions?

xform has redundancy (e.g. bugs/llrb5.slk)

A node with Derived became Original after lemma folding! which example?

view_unfold_num should be made into a verifier option

view_original should be changed from bool to integer
  0 -> original
  1,2,.. -> derived

Printing very indented:
                            [c<=1(IP)& 0<=c(IP)]  [true]  alias set:[@]
                          [d]:  [d<=2(IP)& 0<=d(IP)]  [true]  alias set:
                          [@])) &
                         {FLOW,(52,53)=__norm,}
                           ECase case {c=1 -> ECase case {d=0 -> EAssume 36:
                                                                   EXISTS(bh_123,
                                                                   flted_0_114,
                                                                   flted_0_115,
                                                                   flted_0_116: 

# graph2.txt: DONE

Why do two equivalent expression below give different result!

checkentail
x4::ls<x5>
* x3::node<x4>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.


checkentail
x3::node<x4>
* x4::ls<x5>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.

# test-5a.slk

How come explicit instantiation still have "exist" wrapper?

 checkentail x::sll<n> & n>2 |- [q] x::node<_,q>.

/*

Why is there an EXIST q wrapper for explicit instantiation?

 <1>EXISTS(q,flted_8_243: q::sll<flted_8_243>@M[0][Orig]&n=flted_8_243+1 & 2<n & q=q&{FLOW,(19,20)=__norm})[]


*/
@2! vheap: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]
@2! vheap 2: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]


dprint: bind2.ss:16: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:c::node<Anon_11@M,p@M>@M[Orig]&c=c' & 0<=0 & Anon_11=Anon_33' & nn_34'=p&{FLOW,(22,23)=__norm}[]
       es_var_measures: MayLoop
       es_trace: empty

 ]

dprint: bind2.ss:20: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:hfalse&false&{FLOW,(22,23)=__norm}[]

# bind2b1.ss (vs bind2b.ss)  TEMP FIXED fields-->@M

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      bind c to (vv,nn) in { t = nn; };
      dprint;
      return t;
}

/*

Why is this bind inferred as @M?
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[vv_32,nn_33]
@7! node ann:@M
@7! fields ann:[@L,@L]
@7! read-only:false

It should be @L; as in bind2b.ss with
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[val_15_762,next_15_763]
@7! node ann:@L
@7! fields ann:[@A,@L]
@7! read-only:true
@7!bind2b.ss:15: 10: bind: unfolded context:



*/


# bind2b2.ss   DONE

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      t = bind c to (vv,nn) in nn ;
      dprint;
      return t;
}

/*

Why is there a parsing error for bind in the RHS of assignment?

File "bind2b2.ss", line 15, characters 8-9
 --error: Stream.Error("[expression] expected after EQ (in [assignment_expression])")


*/

# bind2e.ss

 bind node lost during exception!

bind node not released by exception!
  1. restore
  2. use try-catch for bind?

dprint: bind2e.ss:17: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
Escaped States:
[
 
 Try-Block:0::
 [
  Path: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]
 ]


# bind2{e3,e4}.ss  DONE 
     (via CF.normalize_max_renaming_list_failesc_context_4_bind)

dprint: bind2e4.ss:18: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
!!! bind:tmp_res1:[ Escaped States:
 [
  
  Try-Block:62::
  [
   Path: 
   State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
         es_var_measures: MayLoop
         es_trace: empty

   ];
  
  ]]

bind2e3.ss

!!! bind:tmp_res1:[ 
 Successful States:
 [
  Label: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]]


# TODO how about field level access for bind2{e3,e4}.ss

Trung:

Could you try fix the type problem below 
at default branch? If possible, please also
support type annotation at the infer parameter
list by changing the parser, e.g:
  infer [(x:int)] x=3 & x=x' |-  x>4.

# bugs/cll-type.slk

// why "could not find coherent-type below" ?
// x & x' has the same int type
infer [x] x=3 & x=x'
 |-  x>4.

# cll-t2.slk  FIXED by Trung

infer [x] x::node<val_35_804,next_35_805> & y=null
 |-  y!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

It is not necessary for x to be on both sides;
just one side is sufficient.
*/

infer [x] x::node<val_35_804,next_35_805> & x=y
 |-  x!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

But x ia already on both sides!
*/
==============================================
# bugs/app-2.slk  FIXED

checkentail x::ll_tail2<tx,nnn>@M 
 |-  tx::node<a,b>@L. 
// |-  tx::node<a,b>. 

-dd tracing

It seems that lemmas are not being triggered for@L.

With @L, I got

!!!:0: 0: do_base_case_unfold attempt for :  r_121::ll_tail2<tx_118,flted_12_119>@M[1][Orig]
!!!:0: 0: do_base_case_unfold attempt : unsuccessful for :  r_121::ll_tail2<tx_118,flted_12_119>@M[1][Orig]
!!!:0: 0: process_action :
 ### action =  LHSCaseAnalysis =>
                    Type: MaterializedArg (tx,partial,) view_defn_mater
                    LHS: x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]
                    RHS: tx::node<a,b>@L[Orig]
 lhs_rest: Hole[93]
 rhs_rest: emp
 ### estate =  x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]&true&{FLOW,(19,20)=__norm}[]
 ### conseq =  tx::node<a,b>@L[Orig]&true&{FLOW,(19,20)=__norm}[]


!!!:0: 0: do_lhs_case : unsuccessful for :  x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]
Entail (1) : Fail.


With @M, I got:

!!!:0: 0: process_action :
 ### action =  Lemma ==> ll_tail2 =>
                       Type: MaterializedArg (tx_116,partial,) coerc_defn_mater: ==> ll_tail2
                       LHS: r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]
                       RHS: tx::node<a,b>@M[Orig]
 lhs_rest: x::node<Anon_118,r_119>@M[Orig]
 rhs_rest: emp
 ### estate =  x::node<Anon_118,r_119>@M[Orig] * r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]&nnn=flted_12_117+1 & r_119!=null & tx=tx_116&{FLOW,(19,20)=__norm}[]
 ### conseq =  tx::node<a,b>@M[Orig]&true&{FLOW,(19,20)=__norm}[]


!!!:0: 0: do_coercion: estate : es_formula: 
  x::node<Anon_118,r_119>@M[Orig] * 
  r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]&nnn=flted_12_117+1 & 
  r_119!=null & tx=tx_116&{FLOW,(19,20)=__norm}[]
 es_pure: true
 es_orig_ante: None

============================================================
# bug-base-case-2.slk  FIXED (lhs-case disabled by default)

performance bug

lhs-case-analysis seem to have triggered many alternatives:
Is there a way to apply lemma wo resorting to LHS case analysis,
so that (1) would work

Entail (2) : Valid. 

 <1>
    emp&q3=t & q=self & n!=self & q3=t & Anon_16=Anon_17 & q3!=self&
    {FLOW,(19,20)=__norm}[]
    or emp&n!=self & q3!=t & Anon_16=Anon_17 & self!=t&
       {FLOW,(19,20)=__norm}[]
    
<2>
   emp&q3=t & q=self & n!=self & q3=t & Anon_16=Anon_17&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & q3!=t & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]
   
<3>emp&n!=self & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]
<4>
   emp&q3=t & q=self & n!=self & Anon_16=Anon_17 & q3=t & q3!=self&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & Anon_16=Anon_17 & q3!=t & self!=t&{FLOW,(19,20)=__norm}[]
   
<5>
   emp&q3=t & q=self & n!=self & Anon_16=Anon_17 & q3=t & q3!=self&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & Anon_16=Anon_17 & q3!=t & self!=t&{FLOW,(19,20)=__norm}[]

--dis-lhs-case

Entail (2) : Valid. 

 <1>emp&n!=self & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]

================================================================================================
# bug-lem-2.slk  FIXED

lemma "dll_r5_tail2" self::dll_r5<p,t,n>  
  <- self::dll_r5<p,q,t> * t::node<_,q,n> & self!=n.

/*

find_materialized_prop@1
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : {1}->EXISTS(p_13,t_14,q_15,n_16,q,Anon_11: 
 self::node<p_13,q,t_14>@M[Orig] * t::node<Anon_11,q_15,n_16>@M[Orig]
   &n!=self & p=p_13 & t=t_14 & q=q_15 & 
  n=n_16&{FLOW,(1,22)=__flow})[]

find_materialized_prop@1 EXIT out :[ (self,full,), (t,full,)]

find_materialized_prop@2
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : 
EXISTS(q_32,Anon_12,q: 
 self::dll_r5<p,q,t>@M#O[dll_r5_tail2][0][Derv][LHSCase] * 
 t::node<Anon_12,q_32,n>@M[Derv]&n!=self & q=q_32&{FLOW,(1,22)=__flow})[]

find_materialized_prop@2 EXIT out :[ (n,full,[dll_r5]), (p,full,[dll_r5]), (self,full,[dll_r5]), (t,partial,)]

find_materialized_prop@3@2
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : EXISTS(q_33,Anon_12,
q: self::dll_r5<p,q,t>@M#O[dll_r5_tail1][0][Derv][LHSCase] * 
t::node<Anon_12,q_33,n>@M[Derv]&q=q_33&{FLOW,(1,22)=__flow})[]
find_materialized_prop@3 EXIT out :[ (n,full,[dll_r5]), (p,full,[dll_r5]), (self,full,[dll_r5]), (t,partial,)]

EXPECT:
 find_materialized_prop@3 EXIT out :[(self,full,[dll_r5]), (t,partial,)]

*/

pred A<> == self=null  or  self::tree<c>* c::B<>
 inv true.
pred B<> == self=null or  self::node<c>* c::A<>
 inv true.

===================================================================

# mut-bug-1.slk  FIXED

Why is B<> pick as a type decaration rather
than view declaration? In mut-1.slk, we can
have mutual predicates with more than 1 parameter.

SOLN : If type declaration is not found, please
 assume that it is a view declaration.


ERROR: at mut-bug-1.slk_15:42_15:48 
Message: no type declaration named B is found
 
ERROR: at mut-bug-1.slk_17:41_17:47 
Message: no type declaration named A is found
===================================================================
# bugs/rose-bug-type.ss 

Why is there a type: check_child$node~tree~null

ERROR: at rose-bug-type.ss_31:15_31:45 
Message: trans_exp :: case CallNRecv :: procedure 2 check_child$node~tree~null is not found
 Stop Omega... 26 invocations Halting Reduce... 
caught
===================================================================
# bugs/rose-bug-type2.ss 

Typechecker has failed to pick error below with check_child(t.children,t,t)

Why wasn't check_child(t.children,t,t) flagged
as a type error. The error only appeared during trans_exp

ERROR: at rose-bug-type2.ss_32:15_32:42 
Message: trans_exp :: case CallNRecv :: procedure 2 check_child$node~tree~tree is not found
===================================================================
# swl.ss --en-logging-txt -tp om

PROBLEMS (i) could simplifier help push existential inwards
             and/or eliminate them, e.g nxt can be elim, while
             Mnt can be pushed inwards
(ii) Why ante/conseq seems to be wrong way for some examples
     such as 149 below.
-------------------- 
 id: 150; prover: ; loc: swl_ss_12:11_12:43; kind: Pred_Check_Inv
 Simplify:  exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s))
 res:  exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s))
 -------------------- 
 id: 149; prover: ; loc: swl_ss_12:11_12:43; kind: Pred_Check_Inv
 Imply: ante: s!=self
	     conseq:  (exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s)) | (self=null & M=bag() & s!=self))
 res: false
 -------------------- 
===================================================================
# swl-num.ss

Why ante/conseq seem to be reversed here? Is this
really required since we known inv is just an approx.

id: 150; prover: OMEGA CALCULATOR; loc: swl-num_ss_12:11_12:40; kind: Pred_Check_Inv
 Imply: ante: 0<=n & s!=self
	     conseq:  ((n=0 & self=null & self<=(s-1)) | (s<self & self!=null & 1<=n) | 
(self!=null & self<s & 1<=n) | (n=0 & s<self & self=null))
 res: false
===================================================================
# "bug-lbl-1.ss"

lg<"n":s,"b":M> == true & ["n":self = null & self != s; "b":M = {}] 
	or self::node<_,nxt> * nxt::lg<s,Mnxt> & ["b": M = union(Mnxt,{self}); "n": self != s]
inv ["n":self!=s];

since inv is supposed to contain just pure, why can't
we have:
inv ["n":self!=s];

Parsing file "bug-lbl-1.ss" by default parser...
File "bug-lbl-1.ss", line 9, characters 4-5
 --error: Stream.Error("[exl_pure] expected after OSQUARE (in [cexp_w])")
 at:(Program not linked with -g, cannot print stack backtrace)
===================================================================
# swl-lbl.ss -tp om --en-logging-txt

poor exists formation at expense of labels.
On the LHS, perhaps existential can be removed by
simply replacing with free vars. On the RHS,
existentials must be kept.

 id: 157; prover: MONA; loc: swl-lbl_ss_8:4_8:87; kind: Compute_Base_Case
 Simplify:  exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
bag({self})))
 res:  exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
bag({self})))

how did we get a [b,n]:

 id: 161; prover: MONA; loc: swl-lbl_ss_8:4_8:87; kind: Compute_Base_Case
 Sat:  (((AndList ([],self!=null) & ([b],M=union(bag(),bag({self})))
 & ([n],self=null & s!=self & s!=self & s!=null)) ) | 
((AndList ([b,n],exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
          exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
          bag({self}))) & s!=self & self!=null)
 & ([n],self=null & s!=self)) ))
 res: UNSAT

===================================================================
./hip bugs/schorr-waite-list.ss -tp om --en-logging-txt  > a

We have 4 large timeout from the above. Two of them seem to have exceeded
the 5s timeout we impose on mona proof. Why is this so?

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 17.149072; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 4.832302; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 26.361647; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 4.880305; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

However, when I run it separately as a sleek command;
it seems to have adhered to the default time limits.
----------------


no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 21.965372; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 9.73661; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 9.732609; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

--------

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 16.365021; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 3.908244; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 25.205576; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 3.864241; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:1749: id: 314; prover: MONA; TIME: 42.110632; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

-------


----------

which seems to have exceeded the 3 sec timeout we placed
for imply_timeout. Can we check why these are not being
enforced by mona prover?

imply_timeout@34
imply_timeout inp1 : Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & 
cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & v_bool_38_945' & 
cur_1026=null & v_bool_38_945' & cur'=prev_1027 & prev'=null & 
exists(sentinel_1061:cur'=sentinel_1061) & Mc_1030=bag() & 
exists(sentinel_1062:prev'!=sentinel_1062) & Mp_1031=bag() & 
(((exists(Mnxt:Mnxt_1007=union(Mnxt,bag({nxt_1006}))) & nxt_1006!=s_1004 & 
nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & nxt_1006!=s_1004))) & 
(((exists(M1:Mp=union(bag({prev}),M1)) & prev!=sentinel_1009 & prev!=null) | 
(prev=sentinel_1009 & Mp=bag()))) & cur_1016!=null
imply_timeout inp2 : cur'=sentinel'
imply_timeout inp3 :timeout:3.
imply_timeout inp4 :234
imply_timeout@34 EXIT out :false
[mona.ml]:Timeout exception


 id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
 Imply: ante: Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & 
v_bool_38_945' & cur'=prev_1027 & prev'=null & Mc_1030=bag() & 
exists(sentinel_1108:prev'!=sentinel_1108) & Mp_1031=bag() & 
(((exists(Mnxt_1107:Mnxt_1007=union(Mnxt_1107,bag({nxt_1006}))) & 
nxt_1006!=s_1004 & nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & 
nxt_1006!=s_1004))) & (((exists(M1_1106:Mp=union(bag({prev}),M1_1106)) & 
prev!=sentinel_1009 & prev!=null) | (prev=sentinel_1009 & Mp=bag()))) & 
cur_1016!=null
	     conseq:  cur'=sentinel'
 res: false

===================================================================
# bug-2-swl.ss -tp om -nxpure 0

Procedure lscan$node~node~node FAIL-2

Exception Failure("Mona translation failure!!\nError in file monatemp line  column ") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure lscan$node~node~node
Stop Omega... 37 invocations 
1 false contexts at: ( (42,24) )

Total verification time: 30.165884 second(s)
	Time spent in main process: 0.380023 second(s)
	Time spent in child processes: 29.785861 second(s)
===================================================================
# bug-3-view-swl.ss -tp om  # FIXED

when the invariant of a view fail, it did not report
a view name which could be helpful.
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
