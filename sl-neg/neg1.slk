data node {
  int val;
  node next;
}.

pred ll<n> == self=null & n=0
  or self::node<v,q>*q::ll<n-1>
  inv n>=0.

pred lsort<s,n> == self::node<s,q>*q::node<s2> & s<=s2 & n=2
  or self::node<s2,q>*q::lsort<s,n-1> & s<=s2
  inv n>=2.

/*
infer sl-neg
- uniform_args ll<s,n>
- infer _n_lsort<s,n>
- simplify_args ==> _n_lsort<n>
*/
pred nlsort<n> == self=null & n=0
  or self::node<s2,q>*q::lsort<s,n-1> & s>s2
  or self::node<s2,q>*q::nlsort<n-1>
  inv n>=0.

lemma self::nlsort<n> -> self::lsort<_,n> & flow __Error.

//new notation for counter predicate - disjoint/universal set
lemma self::ll<n> <-> self::lsort<_,n> + self::nlsort<n>.
/*
todo:
- complex lemma - disjoint/universal lemma
- how to prove this lemma?
- how to infer the counter predicates
*/
// (1) MAY = OK LOR MUST
checkentail x::ll<n> |- x::lsort<a,b>.
//print residue.

//1a.
checkentail x::lsort<a,b> |- x::lsort<a,b>.

//1b.
checkentail x::nlsort<b> |- x::lsort<a,b>.
