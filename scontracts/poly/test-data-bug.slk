data node{
   int val;
   node next;
}.

// polymorphic node
data nodep[`T]{
   `T val;
   nodep[`T] next; // remember to write this [`T] -> should throw an error if there isn't
}.

// checkentail x::nodep<z1,t> * z1::node<aa,bb> |- x::nodep<z2,t> * z2::node<cc,dd>.
 // checkentail x::nodep<z1,t> * z1::node<aa,bb> |- x::nodep<z2,t>.
 //checkentail x::nodep<1,t> |- x::nodep<z2,t>.
//checkentail x::node<z1:int,t> |- x::node<z2:int,t>xx.
// checkentail x::nodep<z1:int,t> |- x::nodep<z2:int,t>.
// checkentail x::nodep<1111:int,t> |- x::nodep<z2,t>.
// checkentail x::node<z1:int,t> |- x::node<z2,t>.
// checkentail x::node<(1+2):bool,t> |- x::node<z2,t>.
// checkentail x::node<1:bool,t> |- x::node<1,t>.
// checkentail x::node<z1,t> |- x::node<z2,t>.
 // checkentail x::nodep<z1,t> & z1=2 |- x::nodep<z2,t>.

//checkentail x::node<false,t> |- true.
checkentail x::nodep<false,t>[int] |- true.
print residue.
expect Valid.



/*
A.
z2: implicitly instantiated
checkentail x::node<z1,t> |- x::node<z2,t>.
=>
(early instantiation)
checkentail x::node<z1,t> & z1=z2 |- x::node<z2,t>.


B.
z2: existantially quantified
checkentail x::node<z1,t> |- exists z2: x::node<z2,t>.
==>
(substitution)
checkentail x::node<z1,t> |- [z1/z2] exists z2: x::node<z2,t>.

*/
