pred_prim Trans{%P}<sender,receiver>. //trans
pred_prim Sess{%P}<>.   //session
pred_prim Chan{%P}<>.  //channel
pred_prim Common{%P}<>.
pred_prim S{-%P}<a@IP>. //send
pred_prim R{+%P}<a@IP>. //receive
pred_prim Seq{%P,%P}<>. //sequence
pred_prim SOr{%P}<>.    //disjunction
/*pred_prim Pred{%P}<>. //spred */

/* fences */
pred_prim Fence<peers,chan,id>.
relation  fnce(Channel c,int id).

/* orders */
pred_prim Event<peer,id:int>. //event
pred_prim HB{%P, %P}<>. //hb
pred_prim CB{%P, %P}<>. //cb

/* protocol lang related */
pred_prim Assume{%P}<>. //assumed
pred_prim Guard{%P}<>.  //guard

/* explicit sync */
pred_prim NOTIFY{%P}<>.
pred_prim WAIT{%P,%P}<>.
pred_prim NOT{%P}<>.
pred_prim IMPL{%P,%P}<>.

/* special specs */
pred_prim OPEN   {%P,%P}<>.
pred_prim OPENED        <G,P,c>. //P->peers, G->global prot, c->program channel, root->logical chan
pred_prim EMPTY         <G,c,c>.
pred_prim Peer          <G>.     //peer
pred_prim Party  {%P}   <G,C>.   //%P -> spec,C->bag of channels,G->Global prot
pred_prim INITALL       <B>.
pred_prim INIT          <G>.
pred_prim GLOB   {%R}   <P,C>.   //parties,channels
pred_prim PROJP  {%R}   <>.      // root->party,   %R->global prot
pred_prim PROJC  {%R}   <P>.     // root->channel, %R->global prot, P->party
pred_prim BIND          <G,C>.   // root->party, G->glob prot, C->channels
relation  PeerRel       (int G, int P).

/* orders relation */
/* need to sync this rel definitions with chr_orders_prelude */
relation oev(int n,int m).                  //event
relation ohb(int n1,int m1,int n2,int m2).  //hb
relation ohbp(int n1,int m1,int n2,int m2). //hbp
relation ocb(int n1,int m1,int n2,int m2).  //cb
/* sleek relations */
relation ev(int n).                         //sevent
relation hb(int n1,int n2).                 //shb
relation hbp(int n1,int n2).                //shbp
relation cb(int n1,int n2).                 //scb
relation snot_eq(int a,int b).


/* apply A+ before G- */
lemma_norm@0 "A+" self::Chan{@S Assume{%P}<>;;%R}<> -> self::Chan{@S %R}<> * %P.
/* to check if * %P is neccessary in the body of this lemma */
lemma_norm@1 "G-" self::Chan{@S Guard{%P}<>;;%R}<> * %P -> self::Chan{@S %R}<>.
lemma_norm   "IMPL" self::IMPL{%P, %R}<> * %P -> %R.


/* #################################################
      initall({c1..cm}) -> init(c1) * ... init(cm).
   ################################################# */
lemma_norm  "INIT" self::INITALL<B> & B=union({b},B1) & (b notin B1)
                   -> b::INIT<self> * self::INITALL<B1>.
lemma_norm  "INIT_BASE"
                   self::INITALL<B> & B={}
                   -> true.

/* ################################################################
    G({P1..Pn},C)  -> Party(P1,G,C,(G)|P1) * ... * Party(Pn,G,C,(G)|Pn)
   ################################################################ */
lemma_norm "SPLIT_GLOB" self:: GLOB{@S %R}<P,C> & P=union({A},P1) & (A notin P1)
                         ->   A::Party{  A::PROJP{@S %R}<> }<self,C> *
                           self::GLOB{@S %R}<P1,C>.
lemma_norm "GLOB_INIT"  self::GLOB{@S %R}<P,C> & P={}
                         -> self::INITALL<C>.

/* ##########################################################################
   Party(P,{c1...cm},(G)|P) * Peer(P) -> Chan(c1,P,(G)|P,c1) *...* Chan(cm,P,(G)|P,cm)
   only release the per-channel spec when in the abstract state of a peer
   ########################################################################## */
// lemma_norm "PROJ_BIND " self::Party{ %R }<GG,C> * self::Peer<GG>
//                         -> self::Party{  %R }<GG,C> *
//                            self::BIND<GG,C> & PeerRel(self,GG).

// lemma_norm "SPLIT_PROJ" self::Party{  self::PROJP{@S %R}<> }<GG,C>
//                         & C=union({ccc},C1) & (ccc notin C1) & PeerRel(self,GG)
//                          -> ccc::Chan{ ccc::PROJC{@S %R}<self>}<> *
//                             self::Party{ self::PROJP{@S %R}<> }<GG,C1>.

// lemma_norm "PROJ_CLEAN" self::Party{  self::PROJP{@S %R}<> }<GG,C> & C={}
//                         -> true.
